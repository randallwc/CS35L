#!/usr/bin/python

# William Randall
# topo_order_commits.py

"""
use /usr/local/cs/bin/python3

Discover the .git directory
looking for .git in the current directory, and if it doesnâ€™t exist search the
parent directory, etc
Output a diagnostic 'Not inside a Git repository' to standard error
and exit with status 1 if .git cannot be found when the search went all the way
to the / directory

Get the list of local branch names
Figure out what the different directories inside .git do, particularly the refs
and objects directories

Build the commit graph
Each commit can be represented as an instance of the CommitNode class
The commit graph consists of all the commit nodes from all the branches
Each commit node might have multiple parents and children.

for each branch, perform a depth-first search traversal starting from the
branch head
to establish the parent-child relationships between the commit nodes
The traversal should trace through the parents,
and for every possible pair of parent and child,
add the child hash to the parent node's children
and add the parent hash to the child node's parents.
The leaf nodes for each branch will be the root commits for that branch
where the leaf nodes are the nodes without any parents.
Let root_commits be the union of all the leaf nodes across all the branches.
If a commit is not reachable from any of the branch heads, it should not be
part of the commit graph

Generate a topological ordering of the commits in the graph
a total ordering of the commit nodes such that all the descendent commit nodes
 are strictly less than the ancestral commits
where nodes in root_commits are the oldest ancestors.
One way to generate a topological ordering is to use a depth-first search

Print the commit hashes in the order generated by the previous step, from
the least to the greatest.
If the next commit to be printed is not the parent of the current commit,
insert a 'sticky end' followed by an empty line before printing the next commit
The 'sticky end' will contain the commit hashes of the parents of the current
 commit, with an equal sign '=' appended to the last hash.
These hashes of the parents, if any, can be printed in any order
separated by whitespace.
If there are no parents, just print an equal sign, '='
This is to inform us how the fragments can be 'glued' together.

if an empty line has just been printed, before printing the first commit
 C in a new segment
print a 'sticky start' line starting with an equal sign, '=', followed by
 the hashes of the children of C
if any, on the same line in any order and separated by whitespace
so that we know which commits led to commit C.
There is no whitespace after the equal sign

if a commit corresponds to a branch head or heads
the branch names should be listed after the commit in lexicographical
order, separated by white space
Note that this rule does not apply to the hashes in the sticky
 starts or sticky ends.

The commit hashes in the sticky starts and sticky ends
are not considered as part of the sequence of topologically
ordered commit output.
They are printed only as a visual guide.
So even if a commit hash has already appeared in a sticky start or
sticky end,
it still must be printed as part of the normal sequence of
topologically ordered commit output.
"""

import zlib
import os
import sys

# class defn
class CommitNode:
    def __init__(self, commit_hash, branches=[]):
        """
        :type commit_hash: str
        :type branches: set
        """
        self.commit_hash = commit_hash
        self.branches = branches
        self.parents = set()
        self.children = set()

    def __str__(self):
        return 'commit_hash: {self.commit_hash}, branches: {self.branches}'.format(self=self)

    def __repr__(self):
        return 'CommitNode<commit_hash: {self.commit_hash}, branches: {self.branches}>'.format(self=self)


# helper fxns
def topo_order_commits():
    # get top level git path
    path = find_git()
    path = path + "/.git/"

    # get information about branches
    branch_meta = find_branches(path)

    # get the information about commits and root_commits
    commit_meta, root_commits = find_commits(path, branch_meta)

    # sort the commits
    s_commits = t_sort(commit_meta, root_commits)

    # print output
    s_start = False
    for i in range(len(s_commits)):
        cur = s_commits[i]
        if i < (len(s_commits) - 1):
            next_com = s_commits[i+1]

        # check for sticky start
        if s_start:
            print("=", end="")
            print_val = commit_meta[cur].children
            print(*print_val)
            s_start = False

        # print branch name
        # and hash
        if len(commit_meta[cur].branches) == 0:
            print(cur)
        else:
            print(cur + " ", end="")
            print_val = sorted(commit_meta[cur].branches)
            print(*print_val)

        # check next commit if it is cur's parent
        # print out sticky end
        if next_com not in commit_meta[cur].parents and i < (len(s_commits) - 1):
            print_val = commit_meta[cur].parents
            print(*print_val, end="")
            print("=\n")
            s_start = True


# depth first search
def dfs(path, hash, commit_meta):
    root_commits = set()
    c_stack = [commit_meta[hash]]
    while len(c_stack) > 0:
        pop_val = c_stack.pop()
        pop_val.parents = parents(path, pop_val.commit_hash)
        # if there are no parents
        if len(pop_val.parents) == 0:
            root_commits.add(pop_val.commit_hash)
            continue
        for p_hash in pop_val.parents:
            if commit_meta.get(p_hash) is not None:
                p_node = commit_meta[p_hash]
                p_node.children.add(pop_val.commit_hash)
                continue
            # create the node
            commit_meta[p_hash] = CommitNode(p_hash)
            p_node = commit_meta[p_hash]
            p_node.children.add(pop_val.commit_hash)
            c_stack.append(p_node)
    return root_commits


# topological sort of commits
def t_sort(commit_meta, root_commits):
    out = list()
    seen_meta = dict()
    c_stack = list(root_commits.copy())
    # loop through stack
    while len(c_stack) > 0:
        top_val = c_stack[-1]
        # document that it has been visited
        seen_meta[top_val] = "seen"
        # find all children that have not been visited
        # this will loop through children aand check the seen_meta value to check if it has been seen
        cur_children = [child for child in commit_meta[top_val].children if seen_meta.get(child) is None]
        # if no unvisited children continue
        if len(cur_children) == 0:
            pop_val = c_stack.pop()
            out.append(pop_val)
            continue
        c_stack.append(cur_children[0])
    return out


# find .git dir
def find_git(d="."):
    # loop until /
    while(os.path.abspath(d) != "/"):
        # loop through each directory in PWD
        for dir in os.listdir(d):
            # if you find the .git directory return
            if os.path.isdir(os.path.join(d, dir)) and dir == ".git":
                return os.path.abspath(d)
        # else go back a directory
        d = "../" + d
    sys.stderr.write("Not inside a Git repository\n")
    sys.exit(1)


# get branch hash vals given .git
def find_branches(path):
    # find .git/refs/heads
    branch_path = path + "refs/heads/"
    # Meta of commit hash key and value of branch name
    branch_meta = dict()
    # check if branch_path is a directory
    if not os.path.isdir(branch_path):
        sys.stderr.write("pathrefs/heads/ is not a directory\n")
        sys.exit(1)
    # walk through branch path
    for root, dirs, files in os.walk(branch_path):
        # loop  through  files in branch_path
        if files:
	        for f in files:
	            # open with flags read and binary
	            hash = open(os.path.join(root, f), 'rb').read().decode("latin-1")
	            hash = hash.strip('\n')
	            # if at the certain hash value it isn't initialized then initialize it
	            if branch_meta.get(hash) is None:
	                branch_meta[hash] = list()
	            # append the data
	            meta = os.path.join(root, f)[len(branch_path):]
	            branch_meta[hash].append(meta)
    return branch_meta


# get meta data for ComitNodes & the root_commits
def find_commits(path, branch_meta):
    obj_path = path + "objects/"
    # CommitNode dictionary with hash and CommitNode
    commit_meta = dict()
    root_commits = set()
    for hash in branch_meta:
        if commit_meta.get(hash) is not None:
            commit_meta[hash].branches = branch_meta[hash]
            continue
        # if node is not already made then make it
        commit_meta[hash] = CommitNode(hash, branch_meta[hash])
        # do depth first search
        dfs_obj = dfs(obj_path, hash, commit_meta)
        root_commits = root_commits.union(dfs_obj)
    # sort so that it will always give same result
    root_commits = sorted(root_commits)
    return commit_meta, root_commits


# from hash find parents from obj file
def parents(obj_path, hash):
    # because first two chars in hash are the folder name
    path = obj_path + hash[:2] + "/" + hash[2:]
    parent_set = set()
    if not os.path.isfile(path):
        sys.stderr.write("no object for hash: " + hash + "\n")
        sys.exit(1)
    obj = open(path, 'rb').read()
    obj = zlib.decompress(obj).decode("latin-1")
    obj = obj.replace("\n", " ")

    # creaete list split at spaces
    obj_meta = obj.split(" ")

    # loop through till you find "author"
    i = 0
    while obj_meta[i] != "author" and i < len(obj_meta):
        if obj_meta[i-1] == "parent":
            parent_set.add(obj_meta[i])
        i += 1
    # sort so that it will always give same result
    parent_set = sorted(parent_set)
    return parent_set


# main function
if __name__ == '__main__':
    topo_order_commits()
